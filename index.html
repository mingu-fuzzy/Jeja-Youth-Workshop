<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PUBLIC 실시간 보드 (Web App JSON)</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", sans-serif; margin: 0; padding: 16px; }
    .top { display: flex; justify-content: space-between; align-items: baseline; gap: 12px; flex-wrap: wrap; }
    .meta { color: #666; font-size: 12px; }
    .err { color: #b00020; font-size: 12px; white-space: pre-wrap; }
    table { border-collapse: collapse; width: 100%; margin-top: 12px; table-layout: fixed; }
    th, td { border: 1px solid #e5e5e5; padding: 10px 8px; text-align: center; }
    th { position: sticky; top: 0; background: #fff; z-index: 1; }

    /* display:none 대신 테이블 행 전용 collapse */
    tr.hidden-row { visibility: collapse; }
  </style>
</head>
<body>
  <div class="top">
    <h2 style="margin:0">PUBLIC 실시간 보드</h2>
    <div>
      <div class="meta" id="meta">로딩 중...</div>
      <div class="err" id="err"></div>
    </div>
  </div>

  <div id="root"></div>

  <script>
    const API_URL = "https://script.google.com/macros/s/AKfycbz66ZZz1niYcvTY8igZbSTj5AXypDUmTVUSq1mLdu7HlwOEzkPLmBffUiYwzFuEANKyLw/exec";
    const API_TOKEN = "mkws_2026_4pK9Qw7xV2nH8dR3aL1c";
    const POLL_MS = 3000;

    const HIDE_FROM_TEXT = "현재";
    const HIDE_FROM_TEXT2 = "총액";
    const HIDE_TO_TEXT = "초기값";

    let tableEl = null;
    let fixedRows = null;
    let lastCells = null;
    let fixedHideStart = null;
    let fixedHideEnd = null;
    let timer = null;
    let badCount = 0;

    // 중첩 poll 방지
    let inFlight = false;

    function setMeta(msg) { document.getElementById("meta").textContent = msg; }
    function setErr(msg) { document.getElementById("err").textContent = msg || ""; }

    function buildFixedTable(header, rowCount) {
      const root = document.getElementById("root");
      root.innerHTML = "";

      const t = document.createElement("table");
      const thead = document.createElement("thead");
      const tbody = document.createElement("tbody");

      const trh = document.createElement("tr");
      for (let c = 0; c < header.length; c++) {
        const th = document.createElement("th");
        th.textContent = header[c] ?? "";
        trh.appendChild(th);
      }
      thead.appendChild(trh);

      for (let r = 0; r < rowCount; r++) {
        const tr = document.createElement("tr");
        for (let c = 0; c < header.length; c++) {
          const td = document.createElement("td");
          td.textContent = "";
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }

      t.appendChild(thead);
      t.appendChild(tbody);
      root.appendChild(t);
      tableEl = t;

      lastCells = Array.from({ length: rowCount }, () => Array.from({ length: header.length }, () => ""));
    }

    function computeHideRangeOnce(rows) {
      if (fixedHideStart !== null && fixedHideEnd !== null) return;

      for (let i = 0; i < rows.length; i++) {
        const joined = (rows[i] || []).join(" ").trim();
        if (fixedHideStart === null && joined.includes(HIDE_FROM_TEXT) && joined.includes(HIDE_FROM_TEXT2)) {
          fixedHideStart = i;
        }
        if (fixedHideEnd === null && joined.includes(HIDE_TO_TEXT)) {
          fixedHideEnd = i;
        }
      }
    }

    function rowShouldBeHidden(i) {
      if (fixedHideStart === null || fixedHideEnd === null) return false;
      if (fixedHideStart > fixedHideEnd) return false;
      return i >= fixedHideStart && i <= fixedHideEnd;
    }

    function updateHeader(header) {
      const trh = tableEl.tHead.rows[0];
      for (let c = 0; c < header.length; c++) {
        const newH = header[c] ?? "";
        if (trh.cells[c].textContent !== newH) trh.cells[c].textContent = newH;
      }
    }

    function updateRows(rows, colCount) {
      const tbody = tableEl.tBodies[0];

      for (let r = 0; r < fixedRows; r++) {
        const tr = tbody.rows[r];

        // 숨김 처리(레이아웃 변화 최소)
        if (rowShouldBeHidden(r)) tr.classList.add("hidden-row");
        else tr.classList.remove("hidden-row");

        // 데이터가 부족하면 이전값 유지(빈값으로 덮어씌워 "사라짐" 방지)
        const row = rows[r] || null;

        for (let c = 0; c < colCount; c++) {
          const td = tr.cells[c];

          // row 자체가 없으면 업데이트 안 함(이전 값 유지)
          if (!row) continue;

          const newVal = (row[c] ?? "").toString();
          const oldVal = lastCells[r][c];

          if (newVal !== oldVal) {
            td.textContent = newVal;
            lastCells[r][c] = newVal;
          }
        }
      }
    }

    function isShapeStable(header, rows) {
      if (!Array.isArray(header) || header.length === 0) return false;
      if (!Array.isArray(rows)) return false;
      for (let i = 0; i < rows.length; i++) {
        if (!Array.isArray(rows[i])) return false;
        if (rows[i].length !== header.length) return false;
      }
      return true;
    }

    async function poll() {
      if (inFlight) return;
      inFlight = true;

      try {
        const url =
          API_URL +
          (API_URL.includes("?") ? "&" : "?") +
          "token=" + encodeURIComponent(API_TOKEN) +
          "&t=" + Date.now();

        const res = await fetch(url, { cache: "no-store" });
        const json = await res.json();

        if (!json || !json.ok) {
          badCount++;
          setErr("API 오류: " + (json?.error || "unknown") + "\n누적: " + badCount);
          return;
        }

        const header = (json.header || []).map(x => String(x ?? ""));
        const rows = (json.rows || []).map(r => (r || []).map(x => String(x ?? "")));

        if (!isShapeStable(header, rows)) {
          badCount++;
          setErr("형식 오류: header/rows 모양이 일정하지 않습니다.\n누적: " + badCount);
          return;
        }

        if (!tableEl || fixedRows === null) {
          fixedRows = rows.length;
          buildFixedTable(header, fixedRows);
        }

        // 부분 데이터 방지: rows가 기대치의 90% 미만이면 무시(화면 유지)
        const minRows = Math.floor(fixedRows * 0.9);
        if (rows.length < minRows) {
          badCount++;
          setErr("갱신 보류: 부분 데이터로 보입니다.\n받은 행: " + rows.length + " / 기대 행: " + fixedRows + "\n누적: " + badCount);
          return;
        }

        computeHideRangeOnce(rows);

        badCount = 0;
        setErr("");

        updateHeader(header);
        updateRows(rows, header.length);

        const stamp = json.updatedAt ? (" / 데이터: " + json.updatedAt) : "";
        setMeta("마지막 갱신: " + new Date().toLocaleString("ko-KR") + stamp);
      } catch (e) {
        badCount++;
        setErr("갱신 실패: " + (e?.message || e) + "\n누적: " + badCount);
      } finally {
        inFlight = false;
      }
    }

    function start(ms) {
      if (timer) clearInterval(timer);
      poll();
      timer = setInterval(poll, ms);
    }

    document.addEventListener("visibilitychange", () => {
      if (document.hidden) start(15000);
      else start(POLL_MS);
    });

    start(POLL_MS);
  </script>
</body>
</html>

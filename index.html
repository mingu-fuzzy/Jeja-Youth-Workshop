<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PUBLIC 실시간 보드 (Web App JSON)</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", sans-serif; margin: 0; padding: 16px; }
    .top { display: flex; justify-content: space-between; align-items: baseline; gap: 12px; flex-wrap: wrap; }
    .meta { color: #666; font-size: 12px; }
    .err { color: #b00020; font-size: 12px; white-space: pre-wrap; }
    table { border-collapse: collapse; width: 100%; margin-top: 12px; table-layout: fixed; }
    th, td { border: 1px solid #e5e5e5; padding: 10px 8px; text-align: center; }
    th { position: sticky; top: 0; background: #fff; z-index: 1; }
    .changed { outline: 2px solid #222; transition: outline 0.6s ease; }
    tr.hidden-row { display: none; }
  </style>
</head>
<body>
  <div class="top">
    <h2 style="margin:0">PUBLIC 실시간 보드</h2>
    <div>
      <div class="meta" id="meta">로딩 중...</div>
      <div class="err" id="err"></div>
    </div>
  </div>

  <div id="root"></div>

  <script>
    // --- Web App JSON API ---
    const API_URL = "https://script.google.com/macros/s/AKfycbz66ZZz1niYcvTY8igZbSTj5AXypDUmTVUSq1mLdu7HlwOEzkPLmBffUiYwzFuEANKyLw/exec";

    // Apps Script에 넣어둔 WEB_API_TOKEN 값과 동일해야 합니다
    // (사용자 스크립트 예시에서: mkws_2026_4pK9Qw7xV2nH8dR3aL1c)
    const API_TOKEN = "mkws_2026_4pK9Qw7xV2nH8dR3aL1c";

    // 2~5초 권장
    const POLL_MS = 3000;

    // "현재 총액" 행부터 "초기값" 행까지 숨김(표에서 안 보이게)
    const HIDE_FROM_TEXT = "현재";
    const HIDE_FROM_TEXT2 = "총액";
    const HIDE_TO_TEXT = "초기값";

    let tableEl = null;
    let fixedRows = null;     // 첫 정상 응답의 rows.length로 고정
    let lastCells = null;     // [r][c] 마지막 표시값
    let fixedHideStart = null;
    let fixedHideEnd = null;
    let timer = null;
    let badCount = 0;

    function setMeta(msg) { document.getElementById("meta").textContent = msg; }
    function setErr(msg) { document.getElementById("err").textContent = msg || ""; }

    function cacheBusted(url) {
      const sep = url.includes("?") ? "&" : "?";
      return url + sep + "token=" + encodeURIComponent(API_TOKEN) + "&t=" + Date.now();
    }

    function buildFixedTable(header, rowCount) {
      const root = document.getElementById("root");
      root.innerHTML = "";

      const t = document.createElement("table");
      const thead = document.createElement("thead");
      const tbody = document.createElement("tbody");

      const trh = document.createElement("tr");
      for (let c = 0; c < header.length; c++) {
        const th = document.createElement("th");
        th.textContent = header[c] ?? "";
        trh.appendChild(th);
      }
      thead.appendChild(trh);

      for (let r = 0; r < rowCount; r++) {
        const tr = document.createElement("tr");
        for (let c = 0; c < header.length; c++) {
          const td = document.createElement("td");
          td.textContent = "";
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }

      t.appendChild(thead);
      t.appendChild(tbody);
      root.appendChild(t);
      tableEl = t;

      lastCells = Array.from({ length: rowCount }, () => Array.from({ length: header.length }, () => ""));
    }

    function flash(el) {
      el.classList.add("changed");
      setTimeout(() => el.classList.remove("changed"), 300);
    }

    function computeHideRangeOnce(rows) {
      if (fixedHideStart !== null && fixedHideEnd !== null) return;

      for (let i = 0; i < rows.length; i++) {
        const joined = (rows[i] || []).join(" ").trim();
        if (fixedHideStart === null && joined.includes(HIDE_FROM_TEXT) && joined.includes(HIDE_FROM_TEXT2)) {
          fixedHideStart = i;
        }
        if (fixedHideEnd === null && joined.includes(HIDE_TO_TEXT)) {
          fixedHideEnd = i;
        }
      }
    }

    function rowShouldBeHidden(i) {
      if (fixedHideStart === null || fixedHideEnd === null) return false;
      if (fixedHideStart > fixedHideEnd) return false;
      return i >= fixedHideStart && i <= fixedHideEnd;
    }

    function updateHeader(header) {
      const trh = tableEl.tHead.rows[0];
      for (let c = 0; c < header.length; c++) {
        const newH = header[c] ?? "";
        if (trh.cells[c].textContent !== newH) {
          trh.cells[c].textContent = newH;
        }
      }
    }

    function updateRows(rows, colCount) {
      const tbody = tableEl.tBodies[0];

      for (let r = 0; r < fixedRows; r++) {
        const tr = tbody.rows[r];

        // 숨김 처리(삭제 X)
        if (rowShouldBeHidden(r)) tr.classList.add("hidden-row");
        else tr.classList.remove("hidden-row");

        const row = rows[r] || [];
        for (let c = 0; c < colCount; c++) {
          const td = tr.cells[c];
          const newVal = (row[c] ?? "").toString();
          const oldVal = lastCells[r][c];

          if (newVal !== oldVal) {
            td.textContent = newVal;
            lastCells[r][c] = newVal;
            flash(td);
          }
        }
      }
    }

    function isShapeStable(header, rows) {
      if (!Array.isArray(header) || header.length === 0) return false;
      if (!Array.isArray(rows)) return false;
      for (let i = 0; i < rows.length; i++) {
        if (!Array.isArray(rows[i])) return false;
        if (rows[i].length !== header.length) return false;
      }
      return true;
    }

    async function poll() {
      try {
        const res = await fetch(cacheBusted(API_URL), { cache: "no-store" });
        const json = await res.json();

        if (!json || !json.ok) {
          badCount++;
          setErr("API 오류: " + (json?.error || "unknown") + "\n누적: " + badCount);
          return;
        }

        const header = (json.header || []).map(x => String(x ?? ""));
        const rows = (json.rows || []).map(r => (r || []).map(x => String(x ?? "")));

        if (!isShapeStable(header, rows)) {
          badCount++;
          setErr("형식 오류: header/rows 모양이 일정하지 않습니다.\n누적: " + badCount);
          return;
        }

        // 첫 정상 응답에서 표를 고정 생성 (이후 리로드/재구성 거의 없음)
        if (!tableEl || fixedRows === null) {
          fixedRows = rows.length;
          buildFixedTable(header, fixedRows);
        }

        // 행 수가 갑자기 크게 줄어든 응답은 무시(부분 스냅샷 방지)
        const minRows = Math.floor(fixedRows * 0.9);
        if (rows.length < minRows) {
          badCount++;
          setErr("갱신 보류: 부분 데이터로 보입니다.\n받은 행: " + rows.length + " / 기대 행: " + fixedRows + "\n누적: " + badCount);
          return;
        }

        // 숨김 구간은 한 번만 찾고 고정
        computeHideRangeOnce(rows);

        badCount = 0;
        setErr("");

        // 표시 갱신 (헤더/셀만)
        updateHeader(header);
        updateRows(rows, header.length);

        const stamp = json.updatedAt ? (" / 데이터: " + json.updatedAt) : "";
        setMeta("마지막 갱신: " + new Date().toLocaleString("ko-KR") + stamp);
      } catch (e) {
        badCount++;
        setErr("갱신 실패: " + (e?.message || e) + "\n누적: " + badCount);
      }
    }

    function start(ms) {
      if (timer) clearInterval(timer);
      poll();
      timer = setInterval(poll, ms);
    }

    document.addEventListener("visibilitychange", () => {
      if (document.hidden) start(15000);
      else start(POLL_MS);
    });

    start(POLL_MS);
  </script>
</body>
</html>

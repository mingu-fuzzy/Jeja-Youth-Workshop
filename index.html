<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PUBLIC 실시간 보드</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", sans-serif; margin: 0; padding: 16px; }
    .top { display: flex; justify-content: space-between; align-items: baseline; gap: 12px; flex-wrap: wrap; }
    .meta { color: #666; font-size: 12px; }
    .err { color: #b00020; font-size: 12px; }
    table { border-collapse: collapse; width: 100%; margin-top: 12px; }
    th, td { border: 1px solid #e5e5e5; padding: 10px 8px; text-align: center; }
    th { position: sticky; top: 0; background: #fff; z-index: 1; }
    .changed { outline: 2px solid #222; transition: outline 0.6s ease; }
    tr.hidden-row { display: none; }
  </style>
</head>
<body>
  <div class="top">
    <h2 style="margin:0">PUBLIC 실시간 보드</h2>
    <div>
      <div class="meta" id="meta">로딩 중...</div>
      <div class="err" id="err"></div>
    </div>
  </div>

  <div id="root"></div>

  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <script>
    const CSV_URL =
      "https://docs.google.com/spreadsheets/d/e/2PACX-1vTUs_ZDJTwEC_IJa43ej0BE_ICbuNM_5lTAi0Y8b_CjcCPtQHQt5_N9UC6RE6cX4md4xAp1pI3sbuOk/pub?gid=0&single=true&output=csv";

    const POLL_MS = 5000;

    // CSV가 몇 열이든 상관없이, 화면엔 B~E(4칸)만 보여줌
    const VIEW_COL_START = 1; // A=0, B=1
    const VIEW_COL_COUNT = 4;

    // 표가 너무 자주 흔들리면 5~8초로 늘리세요
    // const POLL_MS = 7000;

    let tableEl = null;
    let headerTexts = null;

    // "표의 고정 뼈대"를 위해, 처음에 본문 행 수를 고정해둠
    let fixedBodyRows = null;

    // 마지막으로 반영된 값(셀 단위 비교용)
    let lastCells = null;

    let timer = null;
    let badCount = 0;

    function cacheBusted(url) {
      const sep = url.includes("?") ? "&" : "?";
      return url + sep + "t=" + Date.now();
    }

    function setMeta(msg) { document.getElementById("meta").textContent = msg; }
    function setErr(msg) { document.getElementById("err").textContent = msg || ""; }

    function looksLikeHtml(text) {
      const head = (text || "").slice(0, 300).toLowerCase();
      return head.includes("<html") || head.includes("<!doctype") || head.includes("<body");
    }

    function parseCSVStable(text) {
      if (!text) return null;
      if (looksLikeHtml(text)) return null;

      const parsed = Papa.parse(text, { skipEmptyLines: true });
      if (parsed.errors && parsed.errors.length) return null;

      const data = parsed.data || [];
      if (!Array.isArray(data) || data.length < 2) return null;

      return data.map(row => (row || []).map(v => (v == null ? "" : String(v))));
    }

    function sliceToViewCols(matrix) {
      if (!matrix || matrix.length === 0) return matrix;
      return matrix.map(row => {
        const r = row || [];
        const sliced = r.slice(VIEW_COL_START, VIEW_COL_START + VIEW_COL_COUNT);
        while (sliced.length < VIEW_COL_COUNT) sliced.push("");
        return sliced;
      });
    }

    // "현재 총액~초기값" 구간을 '삭제'하지 말고, 숨길 row index 목록으로 만든다
    function computeHiddenBodyRowMask(bodyRows) {
      // bodyRows: [ [c1..c4], [..], ... ]
      let hideStart = -1;
      let hideEnd = -1;

      for (let i = 0; i < bodyRows.length; i++) {
        const joined = bodyRows[i].join(" ").trim();
        if (hideStart === -1 && joined.includes("현재") && joined.includes("총액")) hideStart = i;
        if (hideEnd === -1 && joined.includes("초기값")) hideEnd = i;
      }

      const mask = new Array(bodyRows.length).fill(false);
      if (hideStart !== -1 && hideEnd !== -1 && hideStart <= hideEnd) {
        for (let i = hideStart; i <= hideEnd; i++) mask[i] = true;
      }
      return mask;
    }

    function buildFixedTable(header, bodyRowCount) {
      const root = document.getElementById("root");
      root.innerHTML = "";

      const t = document.createElement("table");
      const thead = document.createElement("thead");
      const tbody = document.createElement("tbody");

      // header
      const trh = document.createElement("tr");
      header.forEach(h => {
        const th = document.createElement("th");
        th.textContent = h;
        trh.appendChild(th);
      });
      thead.appendChild(trh);

      // fixed body rows
      for (let r = 0; r < bodyRowCount; r++) {
        const tr = document.createElement("tr");
        for (let c = 0; c < VIEW_COL_COUNT; c++) {
          const td = document.createElement("td");
          td.textContent = "";
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }

      t.appendChild(thead);
      t.appendChild(tbody);
      root.appendChild(t);
      tableEl = t;

      // lastCells 초기화
      lastCells = Array.from({ length: bodyRowCount }, () => Array.from({ length: VIEW_COL_COUNT }, () => ""));
    }

    function flash(el) {
      el.classList.add("changed");
      setTimeout(() => el.classList.remove("changed"), 350);
    }

    function applyUpdate(header, bodyRows, hiddenMask) {
      // 헤더가 바뀌면(거의 없음) 헤더만 업데이트
      if (!headerTexts) headerTexts = header.slice();

      const theadRow = tableEl.tHead.rows[0];
      for (let c = 0; c < VIEW_COL_COUNT; c++) {
        const newH = header[c] ?? "";
        if (theadRow.cells[c].textContent !== newH) {
          theadRow.cells[c].textContent = newH;
        }
      }

      const tbody = tableEl.tBodies[0];
      const n = fixedBodyRows;

      for (let r = 0; r < n; r++) {
        const tr = tbody.rows[r];

        // 숨김 처리 (삭제 X)
        const shouldHide = !!hiddenMask[r];
        if (shouldHide) tr.classList.add("hidden-row");
        else tr.classList.remove("hidden-row");

        // 데이터가 부족하면 빈칸 유지 (화면 흔들림 방지)
        const row = bodyRows[r] || ["", "", "", ""];

        for (let c = 0; c < VIEW_COL_COUNT; c++) {
          const td = tr.cells[c];
          const newVal = row[c] ?? "";
          const oldVal = lastCells[r][c];

          if (newVal !== oldVal) {
            td.textContent = newVal;
            lastCells[r][c] = newVal;
            flash(td);
          }
        }
      }
    }

    async function poll() {
      try {
        const res = await fetch(cacheBusted(CSV_URL), { cache: "no-store" });
        if (!res.ok) throw new Error("HTTP " + res.status);

        const text = await res.text();
        let matrix = parseCSVStable(text);

        if (!matrix) {
          badCount++;
          setErr("갱신 보류: 비정상 응답(HTML/빈값). 누적 " + badCount);
          return;
        }

        // B~E만 남기기 (열 흔들림 방지)
        matrix = sliceToViewCols(matrix);

        const header = matrix[0];
        const body = matrix.slice(1);

        // 첫 정상 수신 때 "고정 행 수"를 확정하고 테이블 뼈대 생성
        if (!tableEl || fixedBodyRows === null) {
          fixedBodyRows = body.length; // 처음 받은 본문 행 수로 고정
          buildFixedTable(header, fixedBodyRows);
        }

        // 숨길 구간 마스크 계산(삭제가 아니라 숨김)
        // body가 더 짧게 들어오면 mask도 짧으니 fixedBodyRows 길이로 확장
        const rawMask = computeHiddenBodyRowMask(body);
        const hiddenMask = new Array(fixedBodyRows).fill(false);
        for (let i = 0; i < Math.min(rawMask.length, fixedBodyRows); i++) hiddenMask[i] = rawMask[i];

        badCount = 0;
        setErr("");
        const now = new Date();
        setMeta("마지막 갱신: " + now.toLocaleString("ko-KR") + " (행 고정: " + fixedBodyRows + ")");

        // 업데이트(재구성 없이 셀만)
        applyUpdate(header, body, hiddenMask);
      } catch (e) {
        badCount++;
        setErr("갱신 실패: " + (e?.message || e) + ". 누적 " + badCount);
      }
    }

    function start(ms) {
      if (timer) clearInterval(timer);
      poll();
      timer = setInterval(poll, ms);
    }

    document.addEventListener("visibilitychange", () => {
      if (document.hidden) start(15000);
      else start(POLL_MS);
    });

    start(POLL_MS);
  </script>
</body>
</html>

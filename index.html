<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PUBLIC 실시간 보드</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", sans-serif; margin: 0; padding: 16px; }
    .top { display: flex; justify-content: space-between; align-items: baseline; gap: 12px; flex-wrap: wrap; }
    .meta { color: #666; font-size: 12px; }
    .err { color: #b00020; font-size: 12px; }
    table { border-collapse: collapse; width: 100%; margin-top: 12px; }
    th, td { border: 1px solid #e5e5e5; padding: 10px 8px; text-align: center; }
    th { position: sticky; top: 0; background: #fff; z-index: 1; }
    .changed { outline: 2px solid #222; transition: outline 0.6s ease; }
  </style>
</head>
<body>
  <div class="top">
    <h2 style="margin:0">PUBLIC 실시간 보드</h2>
    <div>
      <div class="meta" id="meta">로딩 중...</div>
      <div class="err" id="err"></div>
    </div>
  </div>

  <div id="root"></div>

  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <script>
    const CSV_URL =
      "https://docs.google.com/spreadsheets/d/e/2PACX-1vTUs_ZDJTwEC_IJa43ej0BE_ICbuNM_5lTAi0Y8b_CjcCPtQHQt5_N9UC6RE6cX4md4xAp1pI3sbuOk/pub?gid=0&single=true&output=csv";

    const POLL_MS = 5000;

    // CSV가 6열이든 10열이든 상관없이, 화면엔 "B~E"만 보여주기
    // 0부터 세니까: A=0, B=1, C=2, D=3, E=4
    const VIEW_COL_START = 1;
    const VIEW_COL_COUNT = 4;

    let tableEl = null;
    let lastGoodMatrix = null;
    let timer = null;

    function cacheBusted(url) {
      const sep = url.includes("?") ? "&" : "?";
      return url + sep + "t=" + Date.now();
    }

    function setMeta(msg) { document.getElementById("meta").textContent = msg; }
    function setErr(msg) { document.getElementById("err").textContent = msg || ""; }

    function looksLikeHtml(text) {
      const head = (text || "").slice(0, 300).toLowerCase();
      return head.includes("<html") || head.includes("<!doctype") || head.includes("<body");
    }

    function parseCSVStable(text) {
      if (!text) return null;
      if (looksLikeHtml(text)) return null;

      const parsed = Papa.parse(text, { skipEmptyLines: true });
      if (parsed.errors && parsed.errors.length) return null;

      const data = parsed.data || [];
      if (!Array.isArray(data) || data.length < 2) return null;

      // 2D 문자열 배열
      return data.map(row => (row || []).map(v => (v == null ? "" : String(v))));
    }

    // 1) B~E 4칸만 남기기 (열 수 흔들림 해결)
    function sliceToViewCols(matrix) {
      if (!matrix || matrix.length === 0) return matrix;

      const out = matrix.map(row => {
        const r = row || [];
        const sliced = r.slice(VIEW_COL_START, VIEW_COL_START + VIEW_COL_COUNT);
        while (sliced.length < VIEW_COL_COUNT) sliced.push("");
        return sliced;
      });

      return out;
    }

    // 2) "현재 총액" 행부터 "초기값" 행까지(포함) 숨김
    function filterVisibleRows(matrix) {
      if (!matrix || matrix.length <= 1) return matrix;

      const header = matrix[0];
      const body = matrix.slice(1);

      let hideStart = -1;
      let hideEnd = -1;

      for (let i = 0; i < body.length; i++) {
        const joined = body[i].join(" ").trim();
        if (hideStart === -1 && joined.includes("현재") && joined.includes("총액")) hideStart = i;
        if (hideEnd === -1 && joined.includes("초기값")) hideEnd = i;
      }

      if (hideStart === -1 || hideEnd === -1 || hideStart > hideEnd) return matrix;

      const visibleBody = body.filter((_, idx) => idx < hideStart || idx > hideEnd);
      return [header, ...visibleBody];
    }

    function validateMatrix(matrix) {
      if (!matrix || matrix.length < 2) return { ok: false, reason: "데이터가 너무 짧습니다." };

      const cols = (matrix[0] || []).length;
      if (cols !== VIEW_COL_COUNT) {
        return { ok: false, reason: "열 개수가 기대와 다릅니다. 현재 " + cols };
      }

      for (let r = 0; r < matrix.length; r++) {
        if ((matrix[r] || []).length !== cols) return { ok: false, reason: "행마다 열 개수가 달라졌습니다." };
      }

      return { ok: true, reason: "" };
    }

    function buildTable(matrix) {
      const root = document.getElementById("root");
      root.innerHTML = "";

      const t = document.createElement("table");
      const thead = document.createElement("thead");
      const tbody = document.createElement("tbody");

      const header = matrix[0] || [];
      const body = matrix.slice(1);

      const trh = document.createElement("tr");
      header.forEach(h => {
        const th = document.createElement("th");
        th.textContent = h;
        trh.appendChild(th);
      });
      thead.appendChild(trh);

      body.forEach(row => {
        const tr = document.createElement("tr");
        row.forEach(cell => {
          const td = document.createElement("td");
          td.textContent = cell;
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });

      t.appendChild(thead);
      t.appendChild(tbody);
      root.appendChild(t);
      tableEl = t;
    }

    function sameShape(a, b) {
      if (!a || !b) return false;
      if (a.length !== b.length) return false;
      for (let r = 0; r < a.length; r++) {
        if ((a[r] || []).length !== (b[r] || []).length) return false;
      }
      return true;
    }

    function flash(el) {
      el.classList.add("changed");
      setTimeout(() => el.classList.remove("changed"), 350);
    }

    function updateCells(next) {
      const tbody = tableEl.tBodies[0];
      const nextBody = next.slice(1);
      const prevBody = lastGoodMatrix.slice(1);

      for (let r = 0; r < nextBody.length; r++) {
        const tr = tbody.rows[r];
        if (!tr) continue;

        for (let c = 0; c < nextBody[r].length; c++) {
          const td = tr.cells[c];
          if (!td) continue;

          const newVal = nextBody[r][c] ?? "";
          const oldVal = prevBody[r]?.[c] ?? "";

          if (newVal !== oldVal) {
            td.textContent = newVal;
            flash(td);
          }
        }
      }
    }

    async function poll() {
      try {
        const res = await fetch(cacheBusted(CSV_URL), { cache: "no-store" });
        if (!res.ok) throw new Error("HTTP " + res.status);

        const text = await res.text();
        let matrix = parseCSVStable(text);
        if (!matrix) {
          setErr("갱신 보류: CSV 대신 다른 응답(HTML/빈값)이 내려왔습니다.");
          return;
        }

        // B~E 4칸만 유지 → 열 6 문제 해결
        matrix = sliceToViewCols(matrix);

        // 총액~초기값 구간 숨김
        matrix = filterVisibleRows(matrix);

        const v = validateMatrix(matrix);
        if (!v.ok) {
          setErr("갱신 보류: " + v.reason);
          return;
        }

        setErr("");
        setMeta("정상 수신: 행 " + (matrix.length - 1) + " / 열 " + (matrix[0] ? matrix[0].length : 0));

        if (!tableEl || !lastGoodMatrix) {
          buildTable(matrix);
          lastGoodMatrix = matrix;
          return;
        }

        if (!sameShape(matrix, lastGoodMatrix)) {
          buildTable(matrix);
          lastGoodMatrix = matrix;
          return;
        }

        updateCells(matrix);
        lastGoodMatrix = matrix;
      } catch (e) {
        setErr("갱신 실패: " + (e?.message || e));
      }
    }

    function start(ms) {
      if (timer) clearInterval(timer);
      poll();
      timer = setInterval(poll, ms);
    }

    document.addEventListener("visibilitychange", () => {
      if (document.hidden) start(15000);
      else start(POLL_MS);
    });

    start(POLL_MS);
  </script>
</body>
</html>

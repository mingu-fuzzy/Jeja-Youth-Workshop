<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PUBLIC 실시간 보드</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", sans-serif; margin: 0; padding: 16px; }
    .top { display: flex; justify-content: space-between; align-items: baseline; gap: 12px; flex-wrap: wrap; }
    .meta { color: #666; font-size: 12px; }
    .err { color: #b00020; font-size: 12px; }
    table { border-collapse: collapse; width: 100%; margin-top: 12px; }
    th, td { border: 1px solid #e5e5e5; padding: 10px 8px; text-align: center; }
    th { position: sticky; top: 0; background: #fff; z-index: 1; }
    .changed { outline: 2px solid #222; transition: outline 0.6s ease; }
  </style>
</head>
<body>
  <div class="top">
    <h2 style="margin:0">PUBLIC 실시간 보드</h2>
    <div>
      <div class="meta" id="meta">로딩 중...</div>
      <div class="err" id="err"></div>
    </div>
  </div>

  <div id="root"></div>

  <script>
    const CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTUs_ZDJTwEC_IJa43ej0BE_ICbuNM_5lTAi0Y8b_CjcCPtQHQt5_N9UC6RE6cX4md4xAp1pI3sbuOk/pub?gid=0&single=true&output=csv"

    // 2~5초 추천 (너무 짧으면 모바일에서 배터리/데이터 사용 증가)
    const POLL_MS = 2500;

    // 내부 상태
    let tableEl = null;
    let lastMatrix = null; // 2D 배열(문자열)
    let lastFetchOkAt = 0;

    function cacheBusted(url) {
      const sep = url.includes("?") ? "&" : "?";
      return url + sep + "t=" + Date.now();
    }

    function parseCSV(text) {
      // 간단 CSV 파서 (PUBLIC 용도로 보통 충분)
      // 셀 안에 쉼표/따옴표가 많은 복잡 CSV면 PapaParse 같은 라이브러리가 필요합니다.
      return text
        .trim()
        .split("\n")
        .map(line => line.split(",").map(s => s.trim()));
    }

    function setMeta(msg) {
      document.getElementById("meta").textContent = msg;
    }

    function setErr(msg) {
      document.getElementById("err").textContent = msg || "";
    }

    function buildTable(matrix) {
      const root = document.getElementById("root");
      root.innerHTML = "";

      const t = document.createElement("table");
      const thead = document.createElement("thead");
      const tbody = document.createElement("tbody");

      // 첫 줄을 헤더로 가정
      const header = matrix[0] || [];
      const body = matrix.slice(1);

      const trh = document.createElement("tr");
      header.forEach(h => {
        const th = document.createElement("th");
        th.textContent = h;
        trh.appendChild(th);
      });
      thead.appendChild(trh);

      body.forEach(row => {
        const tr = document.createElement("tr");
        row.forEach(cell => {
          const td = document.createElement("td");
          td.textContent = cell;
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });

      t.appendChild(thead);
      t.appendChild(tbody);

      root.appendChild(t);
      tableEl = t;
    }

    function ensureSizeMatches(matrix) {
      // 행/열 수가 바뀌면 부분 업데이트보다 전체 재구성이 안전
      if (!lastMatrix) return true;
      if (matrix.length !== lastMatrix.length) return false;

      for (let r = 0; r < matrix.length; r++) {
        if ((matrix[r] || []).length !== (lastMatrix[r] || []).length) return false;
      }
      return true;
    }

    function flash(el) {
      el.classList.add("changed");
      setTimeout(() => el.classList.remove("changed"), 400);
    }

    function updateCells(matrix) {
      // tableEl 구조:
      // thead: 1행
      // tbody: matrix.length - 1 행
      const tbody = tableEl.tBodies[0];
      const body = matrix.slice(1);
      const lastBody = lastMatrix.slice(1);

      for (let r = 0; r < body.length; r++) {
        const tr = tbody.rows[r];
        if (!tr) continue;

        for (let c = 0; c < body[r].length; c++) {
          const td = tr.cells[c];
          if (!td) continue;

          const newVal = body[r][c] ?? "";
          const oldVal = lastBody[r]?.[c] ?? "";

          if (newVal !== oldVal) {
            td.textContent = newVal;
            flash(td);
          }
        }
      }
    }

    async function poll() {
      try {
        const res = await fetch(cacheBusted(CSV_URL), { cache: "no-store" });
        if (!res.ok) throw new Error("HTTP " + res.status);

        const text = await res.text();
        const matrix = parseCSV(text);

        const now = new Date();
        setErr("");
        setMeta("마지막 갱신: " + now.toLocaleString("ko-KR"));

        if (!tableEl || !lastMatrix) {
          buildTable(matrix);
          lastMatrix = matrix;
          lastFetchOkAt = Date.now();
          return;
        }

        // 크기 바뀌면 테이블 재구성 (깜빡임 최소화: root만 교체)
        if (!ensureSizeMatches(matrix)) {
          buildTable(matrix);
          lastMatrix = matrix;
          lastFetchOkAt = Date.now();
          return;
        }

        // 값만 업데이트 (깜빡임 최소)
        updateCells(matrix);
        lastMatrix = matrix;
        lastFetchOkAt = Date.now();
      } catch (e) {
        // 네트워크 잠깐 끊겨도 화면은 유지
        setErr("갱신 실패: " + (e?.message || e));
        // 너무 자주 에러 메세지 바뀌며 깜빡이지 않게 meta는 유지
      }
    }

    // 모바일에서 백그라운드 탭일 때 폴링을 줄여 배터리 절약(선택)
    let timer = null;
    function start() {
      if (timer) clearInterval(timer);
      poll();
      timer = setInterval(poll, POLL_MS);
    }

    document.addEventListener("visibilitychange", () => {
      if (document.hidden) {
        // 숨겨졌을 때는 폴링 간격을 늘리거나 중지
        if (timer) clearInterval(timer);
        timer = setInterval(poll, 15000);
      } else {
        start();
      }
    });

    start();
  </script>
</body>
</html>
